
module osv.testgenInfoLeak:

import:
  osv.riscv

metadata:
  Secret, // secret data
  Privileged,  // allowed to access secret data
  InitSecret, // privileged code that sets up secret
  Return-Instr // Return instructions, used for call site tracing

policy:
  testgenInfoLeakPol =

   // explicit failures for non-privileged access to secret data
   storeGrp(mem == _, addr == _, val == [+Secret], env == [-Privileged]
            -> fail "Secret data written to by non-privileged code")
   ^ loadGrp(mem == [+Secret], addr == _, env == [-Privileged]
             -> fail "Secret data read from by non-privileged code")

   // Propogate secret taint
   ^ arithGrp(env == _, op1 == [+Secret], op2 == _ -> env = env, res = op1)
   ^ arithGrp(env == _, op1 == _, op2 == [+Secret] -> env = env, res = op2)
   ^ mulDivRemGrp(code == _, env == _, op1 == [+Secret], op2 == _ -> env = env, res = op1)
   ^ mulDivRemGrp(code == _, env == _, op1 == _, op2 == [+Secret] -> env = env, res = op2)
   ^ immArithGrp(env == _, op1 == [+Secret] -> env = env, res = op1)
   ^ loadGrp(mem == [+Secret], addr == _, env == _ -> env = env, res = mem )
   ^ storeGrp(mem == _, addr == _, val == [+Secret], env == _ -> env = env, mem = val)
   ^ storeGrp(mem == [+Secret], addr == _, val == _, env == _ -> env = env, mem = mem ) 

   // Apply Privileged to PC to track call site from InitSecret code
   ^ allGrp(code == [+InitSecret,+Return-Instr], env == [+Privileged] -> env = env[-Privileged])
   ^ allGrp(code == [+InitSecret], env == [-Privileged] -> env = env[+Privileged])

   // default: allow other operations
   ^ branchGrp(code == _, env == _, op1 == _, op2 == _ -> env = env )
   ^ jumpRegGrp(code == _, env == _, target == _ -> env = env , return = {})
   ^ jumpGrp(code == _, env == _ -> return = {})
   ^ loadUpperGrp(code == _, env == _ -> env = env, dest = {})
   ^ immArithGrp(code == _, env == _, op1 == _ -> env = env, res = {})
   ^ arithGrp(code == _, env == _, op1 == _, op2 == _ -> env = env, res = {})
   ^ loadGrp(code == _, env == _, addr == _, mem == _ -> env = env, res = {})
   ^ storeGrp(code == _, env == _, addr == _, val == _, mem == _ -> env = env, mem = {})
   ^ mulDivRemGrp(code == _, env == _, op1 == _, op2 == _ -> env = env, res = {})
   ^ csrGrp(code == _, env == _, op1 == _, csr == _ -> env = env, csr = {}, res = {})
   ^ csriGrp(code == _, env == _, csr == _ -> env = env, csr = {}, res = {})
   ^ privGrp(code == _, env == _ -> env = env)
   ^ systemGrp(code == _, env == _ -> env = env)
   ^ floatGrp(code == _, env == _ -> env = env)
   ^ atomicGrp(code == _, env == _ -> env = env)

require:
    init ISA.RISCV.Reg.Env                   {}
    init ISA.RISCV.Reg.Default               {}
    init ISA.RISCV.Reg.RZero                 {}
    init ISA.RISCV.CSR.Default               {}
    init ISA.RISCV.CSR.MTVec                 {}

    init Tools.Link.MemoryMap.Default        {}
    init Tools.Link.MemoryMap.UserHeap       {}
    init Tools.Link.MemoryMap.UserStack      {}

    init SOC.IO.UART_0                       {}
    init SOC.Memory.Flash_0                  {}
    init SOC.Memory.Ram_0                    {}

    init SOC.IO.Debug                        {}
    init SOC.IO.TEST                         {}
    init SOC.IO.CLINT                        {}
    init SOC.IO.ITIM                         {}
    init SOC.IO.PLIC                         {}

    init llvm.CFI_Return-Instr               {Return-Instr}

    init testgen.var.secret                  {Secret}
    init testgen.func.init_secret            {InitSecret}
